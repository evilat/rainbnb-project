<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RainBNB Onboarding</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css"
      rel="stylesheet"
      crossorigin="anonymous"
    />
    <style>
      * {
        font-family: "inter", "inter Fallback", ui-sans-serif, system-ui,
          sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",
          "Noto Color Emoji";
      }

      html {
        scroll-behavior: smooth;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        background-color: #0d0f1a;
        color: #f8f9fa;
      }

      body {
        position: fixed;
      }

      body.no-scroll {
        overflow: hidden;
      }

      .main-header {
        height: 100vh;
        background-color: #0d0f1a;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: #f8f9fa;
        padding: 2rem;
      }

      .header-content h1 {
        font-size: 3rem;
        margin: 0;
      }

      .header-content p {
        font-size: 1.5rem;
        margin-top: 1rem;
      }

      .scroll-img {
        position: absolute;
        width: calc(1.375rem + 1.5vw);
        bottom: 20px;
        filter: brightness(0) invert(1) drop-shadow(0 0 8px white);
        filter: white;
        animation: floatUpDown 3s ease-in-out infinite;
      }

      @keyframes floatUpDown {
        0%,
        100% {
          transform: translateY(0px) translateX(-50%);
        }
        50% {
          transform: translateY(-8px) translateX(-50%);
        }
      }

      .scroll-section {
        position: relative;
        height: 100vh;
        overflow: hidden;
      }

      .scroll-container {
        height: 100vh;
        overflow-y: hidden;
      }

      .step-card {
        scroll-snap-align: start;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #1a1d2b;
        padding: 2rem;
        color: white;
        border: none;
      }

      .step-content::-webkit-scrollbar {
        display: none;
      }

      .step-content {
        overflow: auto;
        text-align: center;
        max-height: 100vh;
        max-width: 80vw;
      }

      .step-content {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .store-badge {
        height: 40px;
        margin: 0 0.25rem;
        vertical-align: middle;
      }

      .step-img {
        width: 100%;
        max-width: 300px;
        margin-bottom: 1rem;
        border-radius: 0.5rem;
      }

      .side-nav {
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        z-index: 999;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 1rem;
        padding: 1.5rem 0.5rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      .side-nav button {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #343a40;
        color: #fff;
        border: 2px solid transparent;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease-in-out;
      }

      .side-nav button.active {
        background-color: #ffc107;
        color: #000;
        transform: scale(1.2) translateX(10px);
        border-radius: 1rem;
      }

      .side-nav button:hover {
        background-color: #ffc107;
        color: #000;
      }

      .arrow-nav {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        z-index: 999;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 1rem;
        padding: 1.5rem 0.5rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      .arrow-nav button {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #343a40;
        color: #fff;
        border: 2px solid transparent;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease-in-out;
        font-size: 1.5rem;
      }

      .arrow-nav button:hover {
        background-color: #ffc107;
        color: #000;
      }

      .arrow-nav button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .arrow-nav button:disabled:hover {
        background-color: #343a40;
        color: #fff;
      }

      .side-nav,
      .arrow-nav {
        transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1),
          opacity 0.6s ease;
        opacity: 1;
      }

      .hidden-nav-left {
        transform: translateY(-50%) translateX(-80px) scale(0.5);
        opacity: 0.5;
        pointer-events: none;
      }

      .hidden-nav-right {
        transform: translateY(-50%) translateX(80px) scale(0.5);
        opacity: 0.5;
        pointer-events: none;
      }

      @media (min-width: 768px) {
        .step-content {
          flex-direction: row;
          text-align: left;
          gap: 2rem;
          justify-content: center;
          align-items: flex-start;
          padding-right: 1rem;
        }

        .step-img {
          max-width: 250px;
          width: 100%;
          border-radius: 0.5rem;
          position: sticky;
          top: 70px;
          flex-shrink: 0;
        }

        .step-content h3,
        .step-content p {
          max-width: 400px;
        }

        .step-content h3 {
          max-width: 100vw;
          font-size: 2rem;
          position: absolute;
          top: 30px;
          margin-bottom: 1rem;
        }

        .step-content p {
          font-size: 1rem;
          max-height: 75vh;
          line-height: 1.6;
        }
      }

      @media (max-width: 768px) {
        .step-card {
          padding: 0;
        }

        .step-content {
          padding: 0;
        }

        .step-content h3 {
          margin: 1rem 0rem 1rem;
        }

        .scroll-img {
          content: url("swipe-bottom.png");
        }

        .side-nav {
          left: 0;
          gap: 0.5rem;
          padding: 0.75rem 0.25rem;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
          border-radius: 0 1rem 1rem 0;
        }

        .side-nav button {
          width: 25px;
          height: 25px;
          border: 1px solid transparent;
          font-size: 12px;
          font-weight: unset;
        }

        .side-nav button.active {
          transform: unset;
        }

        .arrow-nav {
          right: 0;
          gap: 0.5rem;
          padding: 0.75rem 0.25rem;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
          border-radius: 1rem 0 0 1rem;
        }

        .arrow-nav button {
          width: 25px;
          height: 25px;
          border: 1px solid transparent;
          font-size: 0.75rem;
        }
      }
    </style>
  </head>
  <body>
    <header class="main-header">
      <h1>Welcome to RainBNB</h1>
      <p>Your decentralized travel companion</p>
      <a href="#stepSection"
        ><img
          class="scroll-img"
          id="scroll-img"
          src="scroll-bottom.png"
          alt="Scroll Down"
      /></a>
    </header>

    <section id="stepSection" class="scroll-section">
      <div class="side-nav hidden-nav-left" id="stepNav"></div>

      <div class="arrow-nav hidden-nav-right">
        <button id="arrowUp" disabled>↑</button>
        <button id="arrowDown" disabled>↓</button>
      </div>
      <div class="scroll-container" id="scrollContainer"></div>
    </section>
    <script>
      Top = document.documentElement.scrollTop = 0;
      document.addEventListener("DOMContentLoaded", () => {
        const stepsData = [
          {
            title: "Install SafePal",
            content: `
      Download SafePal from the 
      <a href="https://play.google.com/store/apps/details?id=io.safepal.wallet" target="_blank"><img class="store-badge" src="playstore-badge.png" alt="Play Store Badge"></a> or 
      <a href="https://apps.apple.com/us/app/safepal-crypto-wallet-btc-nft/id1548297139" target="_blank"><img class="store-badge" src="appstore-badge.svg" alt="App Store Badge"></a>.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Install+SafePal",
          },
          {
            title: "Create an Account",
            content: `
      Open the SafePal app after installation. Select "Create Wallet" and follow the on-screen prompts. 
      Choose a strong password and confirm your agreement to the terms. 
      Once completed, your wallet will be created locally on your device.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Create+Account",
          },
          {
            title: "Backup Mnemonic Phrase",
            content: `
      SafePal will generate a 12/24-word mnemonic phrase. This is your master key.
      <br><br>
      Write these words down in order and store them in a secure, offline place. 
      Never take a screenshot or share your phrase with anyone. Losing it means you lose access to your wallet permanently.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Backup",
          },
          {
            title: "Add OPBNB",
            content: `
      To use dApps on the OPBNB chain, you'll need some OPBNB tokens.
      <br><br>
      You can send OPBNB from a centralized exchange (like Binance) to your SafePal wallet address. 
      Make sure to select the correct OPBNB network and send at least $35 worth to cover gas and onboarding costs.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Add+OPBNB",
          },
          {
            title: "Explore RISE",
            content: `
      In the SafePal app, go to the "DApp" or "Explore" tab at the bottom.
      <br><br>
      In the search bar, enter: 
      <div style="padding: 8px; border-radius: 6px; font-weight: bold;">getrise.pro</div>
      This will open the RISE platform where you can start your journey.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Explore",
          },
          {
            title: "Login",
            content: `
      On the RISE website (getrise.pro), click the "Connect Wallet" button.
      <br><br>
      Choose SafePal as your wallet provider. Confirm the connection in the app.
      You are now logged in and ready to explore features within RISE.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Login",
          },
          {
            title: "Upgrade to Ambassador",
            content: `
      Inside the RISE dashboard, go to your account section.
      <br><br>
      Follow the steps to upgrade your level — this may include completing tasks, referring others, and holding a certain amount of OPBNB.
      <br><br>
      Reach the Ambassador level to unlock advanced features and higher earning potential.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Upgrade",
          },
          {
            title: "Share Referral Code",
            content: `
      After becoming an Ambassador, navigate to your profile or dashboard to find your unique referral code.
      <br><br>
      Copy this code and share it with your network. When others sign up using your code, you’ll earn rewards and bonuses.
    `,
            img: "https://placehold.co/360x640/000000/FFFFFF?font=source-sans-pro&text=Refer+your+friends",
          },
        ];

        const scrollContainer = document.getElementById("scrollContainer");
        scrollContainer.innerHTML = "";

        stepsData.forEach((step, index) => {
          const card = document.createElement("div");
          card.className = "card step-card";

          const contentDiv = document.createElement("div");
          contentDiv.className = "step-content overflow-hidden";

          const title = document.createElement("h3");
          title.textContent = `Step ${index + 1}: ${step.title}`;
          contentDiv.appendChild(title);

          if (step.img) {
            const img = document.createElement("img");
            img.src = step.img;
            img.alt = step.title;
            img.className = "step-img";
            contentDiv.appendChild(img);
          }

          const paragraph = document.createElement("p");
          paragraph.innerHTML = step.content;
          contentDiv.appendChild(paragraph);

          card.appendChild(contentDiv);
          scrollContainer.appendChild(card);
        });

        const nav = document.getElementById("stepNav");
        nav.innerHTML = "";

        stepsData.forEach((_, index) => {
          const btn = document.createElement("button");
          btn.setAttribute("data-step", index);
          btn.textContent = index + 1;
          if (index === 0) btn.classList.add("active");
          nav.appendChild(btn);
        });
      });

      let stepScrollInitialized = false;
      let lastScrollTop = 0;
      let scrollDownStartTime = null;
      let initTimeout = null;

      window.addEventListener("scroll", () => {
        const section = document.getElementById("stepSection");
        const sectionTop = section.offsetTop;
        const scrollY = window.scrollY || window.pageYOffset;
        const scrollingDown = scrollY > lastScrollTop;
        lastScrollTop = scrollY;

        if (stepScrollInitialized || scrollY < sectionTop) {
          scrollDownStartTime = null;
          clearTimeout(initTimeout);
          return;
        }

        if (scrollingDown) {
          if (!scrollDownStartTime) {
            scrollDownStartTime = Date.now();

            initTimeout = setTimeout(() => {
              if (!stepScrollInitialized) {
                stepScroll.init();
                stepScrollInitialized = true;
                setupInitialInputHandlers();
              }
            }, 100);
          }
        } else {
          scrollDownStartTime = null;
          clearTimeout(initTimeout);
        }
      });

      function setupInitialInputHandlers() {
        const onInitialStepWheel = (e) => {
          e.preventDefault();
          const direction = e.deltaY;

          removeInitialListeners();

          if (direction > 0) {
            stepScroll.scrollToStep(1);
          } else {
            window.scrollBy({ top: -94, left: 0, behavior: "smooth" });
            destroyStepScroll();
          }
        };

        let touchStartY = 0;

        const onTouchStart = (e) => {
          touchStartY = e.changedTouches[0].screenY;
        };

        const onTouchEnd = (e) => {
          const touchEndY = e.changedTouches[0].screenY;
          const deltaY = touchStartY - touchEndY;

          removeInitialListeners();

          if (deltaY > 50) {
            stepScroll.scrollToStep(1);
          } else if (deltaY < -50) {
            window.scrollBy({ top: -94, left: 0, behavior: "smooth" });
            destroyStepScroll();
          }
        };

        function removeInitialListeners() {
          window.removeEventListener("wheel", onInitialStepWheel);
          window.removeEventListener("touchstart", onTouchStart);
          window.removeEventListener("touchend", onTouchEnd);
        }

        setTimeout(() => {
          window.addEventListener("wheel", onInitialStepWheel, {
            passive: false,
          });
        }, 100);

        setTimeout(() => {
          window.addEventListener("touchstart", onTouchStart, {
            passive: false,
          });
          window.addEventListener("touchend", onTouchEnd, { passive: false });
        }, 300);
      }
    </script>
    <script>
      function destroyStepScroll() {
        if (typeof stepScroll !== "undefined" && stepScroll.destroy) {
          document.getElementById("scrollContainer").scrollTo({ top: 0, behavior: "smooth" });
          stepScroll.destroy();
        }
        stepScrollInitialized = false;
      }

      let stepScroll = (() => {
        let container, steps, navButtons, stepHeight;
        let currentStep = 0;
        let scrollAnimationFrame = null;
        let lastWheelTime = 0;
        let touchStartY = 0;
        let touchEndY = 0;
        let stepTimeout;

        const listeners = [];

        const easeOutExpo = (t) => 1 - Math.pow(2, -10 * t) * (t < 1 ? 1 : 0);

        const handleScrollableStepContent = (direction, isTouch = false) => {
          const currentCard = steps[currentStep];
          const content = currentCard.querySelector(".step-content");
          const delay = isTouch ? 300 : 100;

          if (!content || content.scrollHeight <= window.innerHeight) {
            return false;
          }

          const normalizedDirection = direction > 0 ? 1 : -1;
          const scrollStep = window.innerHeight * 0.9;
          const targetScrollTop =
            content.scrollTop + normalizedDirection * scrollStep;
          const maxScrollTop = content.scrollHeight - content.clientHeight;

          const willScroll =
            (normalizedDirection > 0 && content.scrollTop < maxScrollTop) ||
            (normalizedDirection < 0 && content.scrollTop > 0);

          if (willScroll) {
            content.scrollTo({
              top: Math.min(Math.max(0, targetScrollTop), maxScrollTop),
              behavior: "smooth",
            });
            return true;
          }

          if (
            normalizedDirection > 0 &&
            currentStep === steps.length - 1 &&
            content.scrollTop >= maxScrollTop - 10
          ) {
            return true;
          }

          if (handleScrollableStepContent._timeout)
            clearTimeout(handleScrollableStepContent._timeout);

          handleScrollableStepContent._timeout = setTimeout(() => {
            handleScrollableStepContent._edgeReached = true;
          }, delay);

          if (handleScrollableStepContent._edgeReached) {
            handleScrollableStepContent._edgeReached = false;
            return false;
          }

          return true;
        };

        handleScrollableStepContent._timeout = null;
        handleScrollableStepContent._edgeReached = false;

        const scrollToStep = (step) => {
          if (step === currentStep || step < 0 || step >= steps.length) return;

          if (stepTimeout) {
            clearTimeout(stepTimeout);
          }

          if (step === 0) {
            const onStepZeroWheel = (e) => {
              e.preventDefault();
              const direction = e.deltaY;

              if (direction < 0) {
                cleanupListeners();
                window.scrollBy({ top: -94, left: 0, behavior: "smooth" });
                destroyStepScroll();
              } else if (direction > 0) {
                cleanupListeners();
                scrollToStep(1);
              }
            };

            let touchStartY = 0;

            const onTouchStart = (e) => {
              touchStartY = e.changedTouches[0].screenY;
            };

            const onTouchEnd = (e) => {
              const touchEndY = e.changedTouches[0].screenY;
              const deltaY = touchStartY - touchEndY;

              if (deltaY > 50) {
                cleanupListeners();
                scrollToStep(1);
              } else if (deltaY < -50) {
                cleanupListeners();
                window.scrollBy({ top: -94, left: 0, behavior: "smooth" });
                destroyStepScroll();
              }
            };

            const cleanupListeners = () => {
              window.removeEventListener("wheel", onStepZeroWheel);
              window.removeEventListener("touchstart", onTouchStart);
              window.removeEventListener("touchend", onTouchEnd);
            };

            setTimeout(() => {
              window.addEventListener("wheel", onStepZeroWheel, {
                passive: false,
              });
            }, 100);

            setTimeout(() => {
              window.addEventListener("touchstart", onTouchStart, {
                passive: false,
              });
              window.addEventListener("touchend", onTouchEnd, {
                passive: false,
              });
            }, 300);
          }

          if (scrollAnimationFrame) {
            cancelAnimationFrame(scrollAnimationFrame);
            scrollAnimationFrame = null;
          }

          const start = container.scrollTop;
          const end = step * stepHeight;
          const change = end - start;
          const duration = 500;
          let startTime = null;

          const animateScroll = (timestamp) => {
            if (!startTime) startTime = timestamp;
            const time = timestamp - startTime;
            const progress = Math.min(time / duration, 1);
            const ease = easeOutExpo(progress);

            container.scrollTop = start + change * ease;

            if (
              window.scrollY + window.innerHeight <
              document.body.scrollHeight - 1
            ) {
              window.scrollTo({
                top: document.body.scrollHeight,
                behavior: "auto",
              });
            }

            if (progress < 1) {
              scrollAnimationFrame = requestAnimationFrame(animateScroll);
            } else {
              scrollAnimationFrame = null;
            }
          };

          scrollAnimationFrame = requestAnimationFrame(animateScroll);
          currentStep = step;

          updateNavUI(step);
        };

        const showNavs = () => {
          document
            .querySelector(".side-nav")
            ?.classList.remove("hidden-nav-left");
          document
            .querySelector(".arrow-nav")
            ?.classList.remove("hidden-nav-right");
        };

        const hideNavs = () => {
          document.querySelector(".side-nav")?.classList.add("hidden-nav-left");
          document
            .querySelector(".arrow-nav")
            ?.classList.add("hidden-nav-right");
        };

        const updateNavUI = (step) => {
          navButtons.forEach((btn) => btn.classList.remove("active"));
          navButtons[step].classList.add("active");

          document.getElementById("arrowUp").disabled = step === 0;
          document.getElementById("arrowDown").disabled =
            step === steps.length - 1;
        };

        const handleWheel = (e) => {
          e.preventDefault();

          const now = Date.now();
          if (now - lastWheelTime < 200) return;
          lastWheelTime = now;

          const direction = e.deltaY;

          if (handleScrollableStepContent(direction)) return;

          if (direction > 0 && currentStep < steps.length - 1) {
            scrollToStep(currentStep + 1);
          } else if (direction < 0 && currentStep > 0) {
            scrollToStep(currentStep - 1);
          }
        };

        const handleKey = (e) => {
          if (e.key === "ArrowDown" && currentStep < steps.length - 1) {
            scrollToStep(currentStep + 1);
          } else if (e.key === "ArrowUp" && currentStep > 0) {
            scrollToStep(currentStep - 1);
          }
        };

        const handleTouchStart = (e) => {
          touchStartY = e.changedTouches[0].screenY;
        };

        let edgeSwipeDetected = false;

        const handleTouchEnd = (e) => {
          const touchEndY = e.changedTouches[0].screenY;
          const deltaY = touchStartY - touchEndY;

          const currentCard = steps[currentStep];
          const content = currentCard.querySelector(".step-content");

          if (!content) return;

          const threshold = 1;
          const isScrollable =
            content.scrollHeight > content.clientHeight * threshold;

          const atTop = content.scrollTop <= 0;
          const atBottom =
            content.scrollTop + content.clientHeight >=
            content.scrollHeight - 2;

          if (!isScrollable) {
            if (deltaY > 50 && currentStep < steps.length - 1) {
              scrollToStep(currentStep + 1);
            } else if (deltaY < -50 && currentStep > 0) {
              scrollToStep(currentStep - 1);
            }
            return;
          }

          const swipingDown = deltaY > 50;
          const swipingUp = deltaY < -50;

          const wantsNext =
            swipingDown && atBottom && currentStep < steps.length - 1;
          const wantsPrev = swipingUp && atTop && currentStep > 0;

          if ((wantsNext || wantsPrev) && edgeSwipeDetected) {
            scrollToStep(currentStep + (wantsNext ? 1 : -1));
            edgeSwipeDetected = false;
          } else if (wantsNext || wantsPrev) {
            edgeSwipeDetected = true;

            clearTimeout(handleTouchEnd._resetTimeout);
            handleTouchEnd._resetTimeout = setTimeout(() => {
              edgeSwipeDetected = false;
            }, 1000);
          } else {
            edgeSwipeDetected = false;
          }
        };

        let isTouchScrollingContent = false;

        const handleTouchMove = (e) => {
          const currentCard = steps[currentStep];
          const content = currentCard.querySelector(".step-content");

          if (!content) return;

          const touchY = e.changedTouches
            ? e.changedTouches[0].screenY
            : e.touches[0].screenY;
          const deltaY = touchStartY - touchY;

          const maxScroll = content.scrollHeight - content.clientHeight;

          if (content.scrollHeight > content.clientHeight) {
            const scrollTop = content.scrollTop;

            if (
              (deltaY > 0 && scrollTop >= maxScroll) ||
              (deltaY < 0 && scrollTop <= 0)
            ) {
              isTouchScrollingContent = false;
            } else {
              isTouchScrollingContent = true;
            }
          }

          if (isTouchScrollingContent) {
            if (e.cancelable) e.stopPropagation();
          } else {
            if (e.cancelable) e.preventDefault();
          }
        };

        const addListener = (target, event, handler, opts = false) => {
          target.addEventListener(event, handler, opts);
          listeners.push(() =>
            target.removeEventListener(event, handler, opts)
          );
        };

        const setupNavButtons = () => {
          navButtons.forEach((btn, i) => {
            addListener(btn, "click", () => scrollToStep(i));
          });
        };

        const setupEventListeners = () => {
          addListener(window, "wheel", handleWheel, { passive: false });
          addListener(window, "keydown", handleKey);
          addListener(container, "touchstart", handleTouchStart, {
            passive: false,
          });
          addListener(container, "touchend", handleTouchEnd, {
            passive: false,
          });
          addListener(container, "touchmove", handleTouchMove, {
            passive: false,
          });
        };

        const setupArrowControls = () => {
          addListener(document.getElementById("arrowUp"), "click", () => {
            if (currentStep > 0) scrollToStep(currentStep - 1);
          });

          addListener(document.getElementById("arrowDown"), "click", () => {
            if (currentStep < steps.length - 1) scrollToStep(currentStep + 1);
          });
        };

        const init = () => {
          document.body.classList.add("no-scroll");
          document
            .querySelectorAll(".step-content")
            .forEach((el) => el.classList.remove("overflow-hidden"));
          container = document.getElementById("scrollContainer");
          steps = document.querySelectorAll(".step-card");
          navButtons = document.querySelectorAll("#stepNav button");
          stepHeight = window.innerHeight;

          setupNavButtons();
          setupEventListeners();
          setupArrowControls();
          updateNavUI(0);
          showNavs();
        };

        const destroy = () => {
          document.body.classList.remove("no-scroll");
          document
            .querySelectorAll(".step-content")
            .forEach((el) => el.classList.add("overflow-hidden"));
          listeners.forEach((remove) => remove());
          listeners.length = 0;
          scrollAnimationFrame && cancelAnimationFrame(scrollAnimationFrame);
          scrollAnimationFrame = null;
          currentStep = 0;
          hideNavs();
        };

        return {
          init,
          destroy,
          scrollToStep,
        };
      })();
    </script>
  </body>
</html>
